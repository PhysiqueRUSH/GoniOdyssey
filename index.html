<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GoniOdyssey</title>
    <link rel="manifest" href="manifest.json">
    <style>
        body { margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; background: #222; font-family: sans-serif; color: white; overflow: hidden; }
        
        /* Toolbar optimis√©e pour 5 √©l√©ments */
        #toolbar { padding: 8px 4px; background: #333; display: flex; gap: 4px; justify-content: space-between; align-items: center; z-index: 10; }
        
        /* Styles boutons condens√©s */
        .btn-style { 
            flex: 1; 
            border: none; 
            padding: 10px 0; 
            border-radius: 5px; 
            font-size: 11px; /* Police r√©duite pour tout faire tenir */
            font-weight: bold;
            cursor: pointer; 
            text-align: center; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            color: white;
            white-space: nowrap; 
        }
        
        /* Couleurs */
        label.camera { background: #007AFF; }
        label.gallery { background: #5856D6; }
        
        /* Bouton 180¬∞ */
        #toggleAngleBtn { background: #8E8E93; }
        #toggleAngleBtn.active { background: #FF9500; border: 1px solid white; } /* Orange quand actif */
        
        button.danger { background: #FF3B30; }
        button.success { background: #34C759; }

        #canvas-container { flex-grow: 1; position: relative; overflow: hidden; display: flex; justify-content: center; align-items: center; background: #000; }
        canvas { max-width: 100%; max-height: 100%; touch-action: none; }
        
        input[type="file"] { display: none; }
    </style>
</head>
<body>

<div id="toolbar">
    <label for="cameraInput" class="btn-style camera">üì∑ Photo</label>
    <input type="file" id="cameraInput" accept="image/*" capture="environment">

    <label for="galleryInput" class="btn-style gallery">üìÇ Dossier</label>
    <input type="file" id="galleryInput" accept="image/*">

    <button id="toggleAngleBtn" class="btn-style">üìê 180¬∞</button>

    <button id="clearBtn" class="btn-style danger">‚ùå Raz</button>
    
    <button id="saveBtn" class="btn-style success">üíæ Enr.</button>
</div>

<div id="canvas-container">
    <canvas id="canvas"></canvas>
</div>

<script>
    // --- PWA Setup ---
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js').then(reg => reg.update());
    }

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Inputs
    const cameraInput = document.getElementById('cameraInput');
    const galleryInput = document.getElementById('galleryInput');
    const toggleAngleBtn = document.getElementById('toggleAngleBtn');

    // State
    let img = new Image();
    let points = []; 
    let draggingPointIdx = -1;
    let showSupplementary = false; // false = angle r√©el, true = (180 - angle)
    
    // --- Gestion Image ---
    const handleImageLoad = (e) => {
        if (e.target.files && e.target.files[0]) {
            const reader = new FileReader();
            reader.onload = (evt) => {
                img.onload = () => {
                    resizeCanvas();
                    points = []; 
                    draw();
                };
                img.src = evt.target.result;
            }
            reader.readAsDataURL(e.target.files[0]);
        }
        e.target.value = ''; 
    };

    cameraInput.addEventListener('change', handleImageLoad);
    galleryInput.addEventListener('change', handleImageLoad);

    // --- Resize Logic ---
    function resizeCanvas() {
        if (!img.src) return;
        const container = document.getElementById('canvas-container');
        const aspect = img.width / img.height;
        const screenAspect = container.clientWidth / container.clientHeight;

        if (aspect > screenAspect) {
            canvas.width = container.clientWidth;
            canvas.height = container.clientWidth / aspect;
        } else {
            canvas.height = container.clientHeight;
            canvas.width = container.clientHeight * aspect;
        }
        draw();
    }
    window.addEventListener('resize', resizeCanvas);

    // --- Math√©matiques ---
    function getAngle(p1, p2, p3) {
        const BA = { x: p1.x - p2.x, y: p1.y - p2.y };
        const BC = { x: p3.x - p2.x, y: p3.y - p2.y };
        const dotProduct = (BA.x * BC.x) + (BA.y * BC.y);
        const magBA = Math.sqrt(BA.x*BA.x + BA.y*BA.y);
        const magBC = Math.sqrt(BC.x*BC.x + BC.y*BC.y);
        if (magBA === 0 || magBC === 0) return 0;
        
        let angleRad = Math.acos(Math.max(-1, Math.min(1, dotProduct / (magBA * magBC))));
        let angleDeg = angleRad * (180 / Math.PI);
        
        return angleDeg; // On retourne le nombre brut (float)
    }

    // --- Rendu ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Image
        if (img.src) {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = "#555";
            ctx.font = "14px Arial";
            ctx.textAlign = "center";
            ctx.fillText("Prenez une photo pour commencer", canvas.width/2, canvas.height/2);
            ctx.textAlign = "left";
        }

        // Date
        const date = new Date().toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: '2-digit' });
        ctx.font = "bold 20px Arial";
        ctx.fillStyle = "white";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 4;
        ctx.fillText(date, 10, 30);
        ctx.shadowBlur = 0;

        // Lignes
        if (points.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = "yellow";
            ctx.lineWidth = 3;
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
        }

        // Angle & Sommet
        if (points.length === 3) {
            let angleVal = getAngle(points[0], points[1], points[2]);
            
            // Logique du bouton 180¬∞
            if (showSupplementary) {
                angleVal = 180 - angleVal;
            }

            const angleText = angleVal.toFixed(1) + "¬∞";

            // Fond du texte
            ctx.fillStyle = showSupplementary ? "rgba(255, 149, 0, 0.8)" : "rgba(0,0,0,0.6)"; // Orange si mode 180 actif
            ctx.fillRect(points[1].x + 10, points[1].y - 30, 75, 25);
            
            // Texte
            ctx.fillStyle = "white";
            ctx.font = "bold 16px Arial";
            ctx.fillText(angleText, points[1].x + 15, points[1].y - 12);
            
            // Arc
            ctx.beginPath();
            ctx.strokeStyle = "white";
            ctx.arc(points[1].x, points[1].y, 20, 0, 2 * Math.PI);
            ctx.stroke();
        }

        // Points
        points.forEach((p, index) => {
            ctx.beginPath();
            ctx.fillStyle = index === 1 ? "red" : "#007AFF";
            ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
        });
    }

    // --- Interactions ---
    
    // Toggle Button Logic
    toggleAngleBtn.addEventListener('click', () => {
        showSupplementary = !showSupplementary;
        if (showSupplementary) {
            toggleAngleBtn.classList.add('active');
        } else {
            toggleAngleBtn.classList.remove('active');
        }
        draw();
    });

    // Touch/Mouse Logic
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: (clientX - rect.left) * (canvas.width / rect.width),
            y: (clientY - rect.top) * (canvas.height / rect.height)
        };
    }

    function isOverPoint(pos) {
        return points.findIndex(p => Math.sqrt((p.x - pos.x)**2 + (p.y - pos.y)**2) < 30);
    }

    const startHandler = (e) => {
        if (!img.src) return;
        if (e.cancelable && e.target === canvas) e.preventDefault();
        const pos = getPos(e);
        const idx = isOverPoint(pos);

        if (idx !== -1) {
            draggingPointIdx = idx;
        } else if (points.length < 3) {
            points.push(pos);
            draw();
        }
    };

    const moveHandler = (e) => {
        if (draggingPointIdx !== -1) {
            if (e.cancelable) e.preventDefault();
            points[draggingPointIdx] = getPos(e);
            draw();
        }
    };

    const endHandler = () => draggingPointIdx = -1;

    canvas.addEventListener('mousedown', startHandler);
    canvas.addEventListener('mousemove', moveHandler);
    canvas.addEventListener('mouseup', endHandler);
    canvas.addEventListener('touchstart', startHandler, {passive: false});
    canvas.addEventListener('touchmove', moveHandler, {passive: false});
    canvas.addEventListener('touchend', endHandler);

    document.getElementById('clearBtn').addEventListener('click', () => { points = []; draw(); });
    document.getElementById('saveBtn').addEventListener('click', () => {
        if (!img.src) return alert("Pas d'image");
        const link = document.createElement('a');
        link.download = `GoniOdyssey-${Date.now()}.jpg`;
        link.href = canvas.toDataURL('image/jpeg', 0.9);
        link.click();
    });
</script>
</body>
</html>
